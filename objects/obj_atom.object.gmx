<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_atom</spriteName>
  <solid>0</solid>
  <visible>0</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>type = noone;
pos_x = xstart;
pos_y = ystart;
pos_xstart = xstart;

kickback_to_x = 0;
kickback_to_y = 0;

death_cnt_checked = false;

mov_speed = 12; //12;
mov_speed_slow = 8; //6;
last_dist = -1;

atom_w = sprite_get_width(spr_atom);
atom_w_half = atom_w / 2;
atom_h = sprite_get_height(spr_atom);
atom_h_half = atom_h / 2;
floor_h = sprite_get_height(spr_floor);
floor_h_half = floor_h / 2;

state = AtomState.Idle;
visible = false;
excited_sprite_index = -1;

p_cnt = 0;
p_number = 1;
p_part = noone;
p_color = c_blue;
p_infront = false;

draw_scale = 1;
draw_x = x;
draw_y = y;
draw_angle = 0;
hint_angle = 0;
wait_angle = 0;
plus_dir = true;
display_hint = false;
hint_type = choose(1,2,3);

electrons_awaiting_launch = 0;
lightning_ball = noone;
lightning_state = LighthingAtomState.Idle;
lightning_shocker = noone;
energyLevel = AtomEnergyLevel.First;
starting_type = AtomType.One; //this is used to know what remnant to create (default to atom one)

cooking_state = CookedState.NotCooked;
laser_cooker = noone;
laser_gun = noone;

is_shotgun_operand = false;

combine_horizontal = true;

lightning_mouse_over = false;

in_game_piece = false;

pipe_end = noone;

next_type_index = -1;
mouse_over = false;

lost = false;

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Effects 
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///MAKE SPARKS
if p_cnt &lt; 1 and visible
{
    p_part = p_atom_lvl3;
    p_cnt = 6;   
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Recycle
if obj_controller.state ==ControllerState.GlobalReactionStarted then exit;

if in_game_piece 
{
    if state == AtomState.Recycling then global.recycle_cnt--;
    if global.recycle_cnt &lt; 0 then global.recycle_cnt = 0;
    scr_push_replacement_atom(id);    
    
} else {

    var xx = pos_xstart;
    var yy = ds_map_find_value(global.column_bottoms, pos_xstart);  
    var empty_space_found = true;
    
    pos_x = 0;
    pos_y = 0;
    
    with(obj_atom)
    {
        if(pos_x == xx and pos_y == yy) empty_space_found = false;
    }
    
    if(empty_space_found)
    {
        x = path_get_x( path_level_1, 0); 
        y = path_get_y( path_level_1, 0); 
        
        pos_x = pos_xstart;
        pos_y = ds_map_find_value(global.column_bottoms, pos_xstart);             
        next_type_index = next_cnt;
        
        if not lost then scr_change_type(obj_next.next_atom_type, true, false);
        lost = false;
        path_start(path_level_1, mov_speed, path_action_stop, true); 
        visible = true;
    } else {
        alarm[1] = 1;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///set atom to visable and in a state of moving
visible = true;
state = AtomState.Moving;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>119</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>1</exetype>
        <functionname>action_path</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>8</kind>
            <path>path_level_1</path>
          </argument>
          <argument>
            <kind>0</kind>
            <string>mov_speed</string>
          </argument>
          <argument>
            <kind>4</kind>
            <string>0</string>
          </argument>
          <argument>
            <kind>4</kind>
            <string>1</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Calculate Draw Values

if display_hint
{    
    if hint_angle &gt;= 360 
    {
        hint_angle = draw_angle = 0;
        display_hint = false;
        draw_x = x;
        draw_y = y;
        draw_scale = 1;
        hint_type = choose(1,2,3);
    } else {
        
        hint_angle += 30;       
        draw_scale = 1;
        switch(hint_type)
        {
            case 1:
                draw_x = x  + sin(hint_angle) * 4;
                draw_y = y;
                break;
            case 2:
                draw_y = y + sin(hint_angle) * 4;
                draw_x = x;
                break;
            default:
                //rotate radius = 45.255
                draw_x = x + atom_w_half + 45.255 * cos(degtorad(135 + hint_angle));
                draw_y = y - (atom_h_half + 45.255 * sin(degtorad(135 + hint_angle))) + atom_h;    
                draw_angle = hint_angle;  
                break;
        }     
    }
}
else if state == AtomState.BeingEatenByReaction
{
    if draw_scale &gt; .1
    {
        draw_scale -= .005; 
        draw_x = x  + (atom_w - atom_w * draw_scale) / 2;
        draw_y = y  + (atom_h - atom_h * draw_scale) / 2; 
    }
}
else if energyLevel == AtomEnergyLevel.Third and state != AtomState.BeingEatenByReaction
{
    if energyLevel == AtomEnergyLevel.Third and alarm[2] &lt; 1 then alarm[2] = room_speed;
    
    if draw_scale &gt;= 1 then plus_dir = true;    
    if draw_scale &lt;= .7 then plus_dir = false;
    if plus_dir then draw_scale -= .01; else  draw_scale += .01;
    
    draw_x = x  + (atom_w - atom_w * draw_scale) / 2;
    draw_y = y  + (atom_h - atom_h * draw_scale) / 2;  
}
else if lightning_mouse_over
{
    if alarm[2] &lt; 1 then alarm[2] = 10;
    
} else {
    draw_angle = 0;
    draw_x = x;
    draw_y = y;
    draw_scale = 1;
}


if state != AtomState.Idle
{
    draw_angle = 0;
    display_hint = false;
    draw_x = x;
    draw_y = y;
    if state != AtomState.BeingEatenByReaction then draw_scale = 1;
}

if state == AtomState.Wait
{
    wait_angle = (wait_angle + 30) % 360;    
    draw_angle = 0;   
    draw_x = x  + sin(wait_angle) * 4;
    draw_y = y  + cos(wait_angle) * 4;
    if state != AtomState.BeingEatenByReaction then draw_scale = 1;
}


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Control the state of the atom 
if obj_controller.state == ControllerState.Paused then exit;

switch(state)
{    
    case AtomState.Idle:
        //if scr_test_sharing_space() then break;
        
        if scr_start_float() then  scr_move_atom(pos_x,  scr_float_2(pos_y - atom_h));
        break;
        
    case AtomState.CombiningAxis:
        if scr_combine_test() 
        {
            scr_combine_complete();            
            state = AtomState.Idle;            
        }
        break; 
    case AtomState.MovingToBeMineOperand:
    case AtomState.MoveToPipeOpening:
    case AtomState.MovingToBeKickedback:
    case AtomState.MovingToBeAntiOperand:
    case AtomState.MovingToBeMissileOperand:
    case AtomState.MovingToBeShotgunOperand:
    case AtomState.MovingToBeLaserOperand:
    case AtomState.MovingToBeLightningOperand:
    case AtomState.Moving:
        if scr_test_position() then scr_stop_atom(); 
        break;
    case AtomState.Recycle: 
        scr_upd_atom_death_cnt();       
        visible = false;
        x = path_get_x( path_level_1, 0); 
        y = path_get_y( path_level_1, 0); 
        if obj_controller.state == ControllerState.Scanning || obj_controller.state == ControllerState.GlobalReactionStarted 
        {
            state = AtomState.Recycling;  
           // if global.recycle_cnt &lt; 0 then global.recycle_cnt = 0;
            alarm[1] = 1; //global.recycle_cnt++ * 5 + 1;  
        } 
        break;  
        
    case  AtomState.Recycling:
    
        break;
    case AtomState.DestroyWithPayoff:
        state = AtomState.Recycle;
        visible = false;
        if(scr_is_excited()) scr_giveup_electrons(ElectronsType.Excited, false, 5);
        else scr_giveup_electrons(ElectronsType.Good, false, 1);        
        break;
    case AtomState.DestroyValid:
        state = AtomState.Recycle;
        visible = false;
        if(scr_is_excited()) scr_giveup_electrons(ElectronsType.Excited, false, 5);           
        break;
    case AtomState.DestroyNotValid:        
        state = AtomState.Recycle;    
        visible = false;   
        scr_giveup_electrons(ElectronsType.Bad, false, 1);     
        break;
    case AtomState.DestroyRestart:
        scr_stop_atom(); 
        visible = false;
        break;        
    case AtomState.ShockStart:
        ///THIS CODE HAS BEEN MOVED TO obj_lightning_shock_Step_1
        /****
        if(scr_is_excited()) scr_giveup_electrons(ElectronsType.Excited, false, 5);
        else scr_giveup_electrons(ElectronsType.Good, false, 10); 
        if lightning_ball == noone then lightning_ball =  instance_create(x,y,obj_ball_lightning);
        state = AtomState.Wait;    
        if type == AtomType.Lightning 
        {
            scr_start_lightning_shock(); //Request Shock!!
            
            //update chain counters 
            lightning_cc++; 
            if global.lightning_cc &gt; global.lightning_max_cc then global.lightning_max_cc = global.lightning_cc;
        }
        ***/
        break;
    case AtomState.ShockEnd:        
        visible = false;
        if lightning_ball != noone then with(lightning_ball)instance_destroy(); 
        lightning_ball = noone;
        state = AtomState.Wait;    
        
        //update vic counters 
        global.lightning_tot_vc++; 
        global.lightning_vc++;  
        if global.lightning_vc &gt; global.lightning_max_vc then global.lightning_max_vc = global.lightning_vc;
    
        scr_smoke_atom(true);        
        break;    
        
    case AtomState.Chosen1:
        draw_scale = .7;
        draw_x = x  + (atom_w - atom_w * draw_scale) / 2;
        draw_y = y  + (atom_h - atom_h * draw_scale) / 2;  
        break
        
    case AtomState.DoppelingStart:
        state = AtomState.Wait;
        break;        
    case AtomState.DoppelingEnd:
        state = AtomState.Idle;
        break;
    case AtomState.LaserStart:
        //wait for the laser gun to switch the state to lasering 
        break;
    case AtomState.Lasering:
        visible = false;
        break;
    case AtomState.LaserEnd:
        state = AtomState.Recycle;
        break;
        
    case AtomState.ShotgunStart:
        //wait for the shotgun gun to switch the state to shotgunning 
        break;
    case AtomState.Shotgunning:
        visible = false;
        break;
    case AtomState.ShotgunEnd:
        state = AtomState.Recycle;
        break; 
    case AtomState.MineExplosionStart:
        //wait for the mine explosion to switch the state to mine explosioning 
        break;
    case AtomState.MineExploding:
        visible = false;
        break;
    case AtomState.MineExplosionEnd:
        state = AtomState.Recycle;
        break;         
    case AtomState.MissileStart:
        //wait for the missile launcher to switch the state to missiling 
        break;
    case AtomState.Missiling:
        if visible 
        {
            var ex = scr_is_excited();
            if ex then scr_giveup_electrons(ElectronsType.Excited, false, 2);
        }
        visible = false;
        break;
    case AtomState.MissileEnd:
        state = AtomState.Recycle;
        break;
    case AtomState.AntiStart:
        //wait for the anti to switch the state to annihilation 
        break;
    case AtomState.AnitAnnihilation:       
        if visible 
        {
            var ex = scr_is_excited();
            if ex then scr_giveup_electrons(ElectronsType.Excited, false, 5);
            else scr_giveup_electrons(ElectronsType.Good, false, 5);
        }
        visible = false;
        break;
    case AtomState.AntiEnd:
        state = AtomState.Recycle;
        break;   
    case AtomState.Kickback:       
        scr_play_snd(Sound.Clank);
        scr_move_atom(kickback_to_x, kickback_to_y);
        break;  
        
    case AtomState.PipeOpeningReached:           
        pipe_end.state = GPPState.AtomAtDestination;             
        break;
}


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Control lightning state

/*******************************************************
The purpose of this code is to make sure that everything 
is in the proper state before staring the lightning SHOCK

The states we are concerned with are the states of the atom 
and the state of the controller. During shocking we do not 
want user interaction so the control needs to get done 
whatever it might be doing before the shocking beings.
********************************************************/

switch(lightning_state)
{
    case LighthingAtomState.Idle:
        break;
    case LighthingAtomState.Shocking:
        break;        
    case LighthingAtomState.DoneShocking:
        break;
        
    case LighthingAtomState.Start:
        lightning_state = LighthingAtomState.AwaitingShockState;
        
        var cy = y + atom_h_half;
        var cx = x + atom_w_half;
        lightning_shocker = instance_create(cx, cy, obj_lightning_shock); //sets lightning_shock_cnt        
        if obj_controller.state != ControllerState.Shocking 
        then obj_controller.requested_shock_state = true;   
        break;
    
    case LighthingAtomState.AwaitingShockState:
        if obj_controller.state ==  ControllerState.Shocking
        {
            if state == AtomState.Idle
            {
                lightning_state = LighthingAtomState.BeginShock;
                state = AtomState.Wait;       
            } else if state == AtomState.Wait {
                lightning_state = LighthingAtomState.BeginShock;
            }
        }       
        break;
        
    case LighthingAtomState.BeginShock:
        lightning_state = LighthingAtomState.Shocking;
        var adj = scr_get_all_adjacent();        
        for(var i= 0; i&lt;8; i++)
            if not scr_ready(adj[i]) then adj[i] = noone;
        
        var cy = y + atom_h_half;
        var cx = x + atom_w_half;
        with(lightning_shocker)
        {   
            x = cx;
            y = cy;
            lg_atom = other.id;
            adjacent = adj; 
            alarm[0] = 2;
        }
        break;    
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Control Cooking State (Being Lasered)

switch(cooking_state)
{
    case CookedState.Start:  
        with(laser_gun) //laser_gun is set by laser beam collision
        {
            cooker_cnt++; 
            state = LaserGunState.Cooking;
        }
        
        if type == AtomType.Laser
        {
            scr_start_laser2(id, laser_gun);
        }        
        else 
        {
            var cy = y + atom_h_half;
            var cx = x + atom_w_half;       
            laser_cooker = instance_create(cx, cy, obj_cooker); 
            laser_cooker.atom = id;   
        }            
        cooking_state = CookedState.Heating;
        break;  
            
    case CookedState.StartCooking:   
        if(scr_is_excited()) scr_giveup_electrons(ElectronsType.Excited, false, 5);
        else scr_giveup_electrons(ElectronsType.Good, false, 5); 
        cooking_state = CookedState.Cooking; 
        break;
        
    case CookedState.Cooking:       
        if electrons_awaiting_launch &lt; 1
        {
            if laser_cooker then with(laser_cooker) instance_destroy(); //shutdown cooker
            laser_cooker = noone;            
            cooking_state = CookedState.Done;     
        }          
        break;    
    
    case CookedState.Done:
        state = AtomState.Recycle;   
        cooking_state = CookedState.NotCooked;    
        scr_smoke_atom(true);   
        
        //update vic counters 
        global.laser_tot_vc++;
        global.laser_vc++;
        global.laser_max_vc = max(global.laser_max_vc, global.laser_vc);

        //update gun
        with(laser_gun)
        {    
            cooker_cnt--;
            if cooker_cnt &lt; 0 then cooker_cnt = 0;
        }
        break;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Control Atom Effects
if p_cnt &gt; 0 then 
{
    var p_x = x + atom_w_half
    , p_y =  y + atom_h_half + speed; 
    
    if p_infront
    then part_particles_create_colour(global.p_system_front, p_x, p_y, p_part,p_color, p_number); 
    else part_particles_create_colour(global.p_system_back , p_x, p_y, p_part,p_color, p_number);    
    p_cnt -= p_number;       
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_ejected_electron">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//with(other)instance_destroy();
/**
if other.done == false and id != other.atom.id and state == AtomState.Idle 
{ 
    other.done = true;
    //with(other)instance_destroy();
    scr_giveup_electrons(ElectronsType.Good, false, 1); 
}
**/
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if type = AtomType.Lightning
{
    image_speed = 1;  
}

lightning_mouse_over = false;
mouse_over = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
if type = AtomType.Lightning &amp;&amp; state == AtomState.Idle 
{
    image_speed = 3;
    lightning_mouse_over = true;
}

mouse_over = true;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="8">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///END OF PIPING
if state == AtomState.Piping 
{
    //scr_move_atom(pos_x, pos_y); 
    state = AtomState.MoveToPipeOpening;
    exit;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///END OF RECYCLE
if state == AtomState.Recycling then global.recycle_cnt--;
if global.recycle_cnt &lt; 0 then global.recycle_cnt = 0;
state = AtomState.Moving;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>105</id>
        <kind>0</kind>
        <userelative>-1</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>1</exetype>
        <functionname>action_move_point</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>0</kind>
            <string>pos_x</string>
          </argument>
          <argument>
            <kind>0</kind>
            <string>pos_y</string>
          </argument>
          <argument>
            <kind>0</kind>
            <string>mov_speed</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>107</id>
        <kind>0</kind>
        <userelative>-1</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>1</exetype>
        <functionname>action_set_gravity</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>0</kind>
            <string>0</string>
          </argument>
          <argument>
            <kind>0</kind>
            <string>0</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Level 3 sparks 

if p_cnt &lt; 1
{
    p_part = global.p_atom_lvl3;
    p_cnt = 6;      
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>state = AtomState.Recycle;
lost = true;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*** DRAW DEPTH
draw_set_font(global.fnt_game_18); 
var yy = y + 10;    
draw_text_ext_transformed(x + 10,yy, string(depth), 2, 300, .5, .5, 0);
****/

if DISPLAY_TYPE_CHANGE_CNT or DISPLAY_ATOM_START_POS
{
    draw_set_font(global.fnt_game_18); 
    if next_type_index &gt;= 0 then draw_text(x,y,string(next_type_index));
    if(mouse_over)draw_text(x,y + 32,string(xstart) + "," + string(ystart));
}

if SHOW_STATE
{
     draw_set_font(global.fnt_game_18); 
     var yy = y + 10; 
     if(mouse_over)
     {
         draw_text_ext_transformed(x + 10,yy, string(pos_x), 2, 300, .5, .5, 0);
     
         yy += 20;
         draw_text_ext_transformed(x + 10,yy, string(pos_y), 2, 300, .5, .5, 0);
         
     } else {
         draw_text_ext_transformed(x + 10,yy, string(state), 2, 300, .5, .5, 0);
     }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
draw_sprite_ext(sprite_index, image_index, draw_x, draw_y, draw_scale, draw_scale, draw_angle, image_blend, image_alpha); 




//draw_sprite_ext(spr_atom_spark, image_index, draw_x, draw_y, draw_scale, draw_scale, image_angle, image_blend, image_alpha); 
//draw_sprite_ext(spr_atom_spark2, image_index, draw_x, draw_y, draw_scale, draw_scale, image_angle, image_blend, image_alpha); 


/**
if draw_scale != 1
{   
    var xx = x  + (atom_w - atom_w * scale) / 2;
    var yy = y  + (atom_h - atom_h * scale) / 2;    
    draw_sprite_ext(sprite_index, image_index, xx, yy, scale, scale, image_angle, image_blend, image_alpha); 
}
else
{
    //rotate radius = 45.255
    // var xx = x + atom_w_half + 45.255 * cos(degtorad(135 + angle));
    // var yy = y - (atom_h_half + 45.255 * sin(degtorad(135 + angle))) + atom_h;
    // draw_sprite_ext(sprite_index, image_index, xx, yy, image_xscale, image_yscale, angle, image_blend, image_alpha); 
    draw_self();    
}
**/
//image_xscale = choose(random_range(0, 1),random_range(0, 1));
//sprite_xoffset = choose(random(10),random(-10));
//view_xview[0]+=choose(random(10),random(-10))
//view_yview[0]+=choose(random(10),random(-10))
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
